' Gambas class file

'this class provides the Core memory object factory
'Public core_memory[8000] As String 'stores the instruction code for each cell
Public core_memory As New String[8000] 'stores the instruction code for each cell
Public core_cell_colour As New Integer[8000] 'stores the colour of the last process which changed this cell
'Public core_cell_colour[8000] As Integer 'stores the colour of the last process which changed this cell
'Public Const Warrior1 As Integer = Color.red 'Color.red
'
'

Public Const vertical_lines As Integer = 88
Public Const horizontal_lines As Integer = 91
Public Const max_core_size As Integer = 8000

'Redcode assembly instruction codes:
'As documented in "The beginners' guide to Redcode" by Ilmari Karonen.
'
' DAT -- data (kills the process)
' MOV - - Move (copies data From one address To another)
' ADD - - add(adds one number To another)
' Sub - - subtract(subtracts one number From another)
' MUL - - multiply(multiplies one number With another)
' Div - - divide(divides one number With another)
' Mod - - modulus(divides one number With another And gives the remainder)
' JMP - - jump(continues execution From another address)
' JMZ - - jump If zero(tests a number And jumps To an address If it 's 0)
' JMN - - jump If Not zero(tests a number And jumps If it isn 't 0)
' DJN - - decrement And jump If Not zero(decrements a number by one, And jumps unless the result Is 0)
' SPL - - Split(starts a Second process at another address)
' CMP - - compare(same As SEQ)
' SEQ - - skip If equal(compares two instructions, And skips the Next instruction If they are equal)
' SNE - - skip If Not equal(compares two instructions, And skips the Next instruction If they aren 't equal)
' SLT - - skip If Lower than(compares two values, And skips the Next instruction If the first Is Lower than the Second)
' LDP - - load From p - Space(loads a number From Private storage Space)
' STP - - save To p - Space(saves a number To Private storage Space)
' NOP - - no operation(does nothing)
'
Public Const I_DAT As String = "dat"
Public Const I_MOV As String = "mov"
Public Const I_ADD As String = "add"
Public Const I_SUB As String = "sub"
Public Const I_MUL As String = "mul"
Public Const I_DIV As String = "div"
Public Const I_MOD As String = "mod"
Public Const I_JMP As String = "jmp"
Public Const I_JMZ As String = "jmz"
Public Const I_JMN As String = "jmn"
Public Const I_DJN As String = "djn"
Public Const I_SPL As String = "spl"
Public Const I_CMP As String = "cmp"
Public Const I_SEQ As String = "SEQ"
Public Const I_SNE As String = "SNE"
Public Const I_SLT As String = "slt"
Public Const I_LDP As String = "ldp"
Public Const I_STP As String = "stp"
Public Const I_NOP As String = "NOP"

Public Const PROCESS_1 As Integer = 1
Public Const PROCESS_2 As Integer = 2

Public grid_cells_x As Integer
Public grid_cells_y As Integer

Public warrior_start_position1 As Integer
Public warrior_start_position2 As Integer

Public current_process As Integer 'nominates which process is the currently active one
Public ip_table1 As New Integer[] 'contains the two process table for the first warriors
Public ip_table2 As New Integer[] 'contains the two process table for the second warriors
Public ip_table_index1 As Integer 'specifies the current index into the instruction pointer table for warrior 1
Public ip_table_index2 As Integer 'specifies the current index into the instruction pointer table for warrior 2


Public Sub SetCellColour(cell As Integer, colour As Integer)
  'Use this function to set each cell colour which has been written to by a process
  
  
End

Public Sub GetCellColour(cell As Integer, colour As Integer)
  'Use this function to get the cell colour for a particular cell
 
  
  
End

Public Sub SetCellContents(cell As Integer, value As String)
  'Use this function to set the cell contents of a specific cell
  
  
End

Public Sub GetCellContents(cell As Integer, value As String)
  'Use this function to get the cell contents of a specific cell
  
  
End

Public Sub ClearCore()
  'Use this function to clear (or zero out) the contents of the entire core, to ensure that if another battle is run, it has a clean core
  core_memory.clear 'wipes all the core contents
  core_memory.Resize(max_core_size)
    
  core_cell_colour.Clear
  core_cell_colour.Resize(max_core_size)
End

Public Sub LoadWarrior(load_point As Integer, code As String, warrior_colour As Integer)
  'given a starting point and the code as a string, will segment the code into lines
  'and inject it into the core_memory array
  Dim code_lines As String[]
  Dim code_line As String
  Dim i As Integer
  
  code_lines = Split(code, "\n")
  For Each code_line In code_lines
    core_memory[load_point + i] = code_line
    core_cell_colour[load_point + i] = warrior_colour
    'DrawWarriorCell(load_point + i)
    i += 1
  Next
  
  DrawCore
  
End

Public Sub DrawCore()
  ' 'paints the drawing area with the contents of the core memory
  ' 'use this var for our loop counter
  Dim counter As Integer
  Dim i, j, k As Integer
  Dim x1, y1, x2, y2 As Integer
  Dim stepx, stepy As Integer
  Dim cursor_pos As Integer
  
  Draw.Begin(DrawingArea1)
  Draw.Clear
  Draw.FillStyle = 1
  Draw.Foreground = Color.Gray
  x1 = 0
  y1 = 0
  x2 = DrawingArea1.Width
  y2 = DrawingArea1.Height
  stepx = (x2 - x1) / vertical_lines + 1
  stepy = (y2 - y1) / horizontal_lines + 1
  
  For i = 1 To vertical_lines + 1
    Draw.Line(x1 + i * stepx, y1, x1 + i * stepx, y2)      
  Next 
  grid_cells_x = i 'Set the number of grid cells in the horizontal length
  
  For j = 1 To horizontal_lines + 1
    Draw.Line(x1, y1 + (j * stepy), x2, y1 + (j * stepy))        
  Next
  grid_cells_y = j 'Set the number of grid cells in the vertical length
  
  'we now paint in the programs as they appear in the core array
  Draw.FillStyle = Fill.Solid
  
  For i = 1 To vertical_lines + 1
     For j = 1 To horizontal_lines + 1
      cursor_pos = i + j * vertical_lines
      If (cursor_pos > 0) And (cursor_pos < max_core_size) Then
        If core_memory[cursor_pos] <> "" Then
          Draw.Foreground = core_cell_colour[cursor_pos]
          Draw.Rect(stepx * i, stepy * j, stepx, stepy)
        Endif
      Endif     
     Next
  Next    
  
  Draw.End
  
End

Public Sub ToolBarRunMode(run_mode As Boolean)
  'switches on or off most of the toolbar buttons
  
  tbPause.enabled = run_mode
  tbStop.enabled = run_mode
  tbStep.enabled = run_mode
  tbOpen1.enabled = Not run_mode
  tbSave1.enabled = Not run_mode
  tbOpen2.enabled = Not run_mode
  tbSave2.Enabled = Not run_mode
  tbRun.enabled = Not run_mode
  
  
End


Public Sub Resize_me()
  
  Dim x, y, PanelH As Integer
  
  'Use this routine to resize and reposition the widgets on the page
  
  x = FMain.width
  y = FMain.height 
  PanelH = Panel1.height + 10
  
  If x < 400 Then Return 'We set a lower limit for width
  If y < 400 Then Return 'We set a lower limit for height
  
  ed1.width = 285
  ed1.x = 10 ' Set the X position of the first editor
  ed1.y = PanelH 'Set the Y position of the first editor
  ed1.height = y - (PanelH + 20) 'Set the height of the first editor
  
  ed2.width = 285
  ed2.X = x - (ed2.Width + 10) ' Set the X position of the second editor
  ed2.y = PanelH 'Set the Y position of the second editor
  ed2.height = y - (PanelH + 20) 'Set the height of the second editor
 
  DrawingArea1.x = ed1.width + 20 
  DrawingArea1.y = Panel1.height + 10 'Set the Y position of the core drawing area
  DrawingArea1.width = FMain.width - (10 + ed1.width + 20 + ed2.width + 10)
  DrawingArea1.height = y - (PanelH + 20) 'Set the height of the core drawing area
   
  'Expander1.width = FMain.width - 20
  'Expander1.height = FMain.height - 50
  DrawCore
End

Public Sub PeekCore()
  'Will determin where the mouse-over correlates to the memory core, and provide that addresse's contents as a pop-up balloon item
  Dim x, y As Integer
  Dim stepx, stepy As Integer
  Dim cursor_pos As Integer
  Dim core_cell_contents As String
  
  'given an x and y position on the drawing area, can we determine which cell that falls into?
  stepx = DrawingArea1.Width / vertical_lines
  stepy = DrawingArea1.Height / horizontal_lines
  'the cell number maps into the core_memory as x*91 + 88
  x = Mouse.x / stepx + 1
  y = Mouse.y / stepy
  cursor_pos = x + y * vertical_lines
  
  If (cursor_pos > 0) And (cursor_pos <= max_core_size) Then
    core_cell_contents = core_memory[cursor_pos]
    If core_cell_contents = "" Then core_cell_contents = "Dat #0, #0" Else core_cell_contents = core_memory[cursor_pos]
    DrawingArea1.tooltip = "Memory Address: " & Str$(cursor_pos) & " :: " & core_cell_contents
  End If
  
End

Public Sub OpenWarrior(warrior As Integer)
    'we need to provide the user with a file open dialog box so they can select a redcode warrior
  Dialog.Title = "Choose a Redcode Warrior file"
  Dialog.Title = "Choose a file"
  Dialog.Filter = ["*.red", "Redcode Files", "*", "All files"]
  Dialog.Path = "."
  If Dialog.OpenFile() Then
    Return ' User pressed Cancel -
  Endif
  If warrior = 1 Then
    ed1.Text = File.Load(Dialog.Path)
    Settings["warrior1"] = Dialog.Path
  Else
    ed2.Text = File.Load(Dialog.Path)
    Settings["warrior2"] = Dialog.Path
  Endif
  
Catch
  Message.Info("Error opening file\n\n" & Error.Text)
  
End

Public Sub Preload_Warriors()
  'preload the warriors last used
  ed1.text = File.Load(Settings["warrior1", "/home/conz/Documents/development/gambas/lmars/warriors/imp.red"])
  ed2.text = File.Load(Settings["warrior2", "/home/conz/Documents/development/gambas/lmars/warriors/dwarf.red"])
  
End

Public Sub Processing()
  'This Is The main routine For executing the code In the battle arena
  'it begins by randozing which of the two warriors starts first
  'this routine maintains state, so the it knows what the last process table used was
  'then it executes one instruction from the process table of the first warrior
  'it then executes one instruction from the process table of the next warrior

  
  'we first check to see if we've gone through here before, i.e, is this our first point of execution?
  If current_process = 0 Then 
    ip_table1.Add(warrior_start_position1)
    ip_table2.Add(warrior_start_position2)
    current_process = Int(Rnd(1, 3))
  End If
  
  'We need to handle Asserts
  ' CORESIZE -- the size of the core (default 8000)
  ' PSPACESIZE - - the size Of the P - Space( Default 500)
  ' MAXCYCLES - - the number Of cycles Until a tie Is Declared( Default 80000)
  ' MAXPROCESSES - - the maximum size Of the process queue( Default 8000)
  ' WARRIORS - - the number Of programs In the core(usually 2)
  ' MAXLENGTH - - the maximum length Of a program( Default 100)
  ' CURLINE - - the number Of instructions compiled so far(0 To MAXLENGTH)
  ' MINDISTANCE - - the minimum distance between two warriors( Default 100)
  ' VERSION - - the version Of pMARS, multiplied by 100(80 Or more)
  
  ''We need to handle #defines
  '
  
  Select Case current_process
    
    Case PROCESS_1
      cpu1() 'execute the code
      ip_table1[ip_table_index1] = ip_table1[ip_table_index1] + 1 'incrememnt the instruction pointer for this process
    Case PROCESS_2
      'cpu2(process_2, core_memory[ip_table1[ip_table_index2]])
      'ip_table1[ip_table_index2] = ip_table1[ip_table_index2] + 1 'incremement the instruction pointer for this process
      
  End Select
  
  
End

Public Sub cpu1()
  'This is the routine which executes the code in the array
  Dim sOpcode, sOpands, sDataA, sDataB As String
  Dim nOpcode, nOpands As Integer
  Dim instruction As String
  
  instruction = core_memory[ip_table1[ip_table_index1]]
  'first, we remove any comments
  If InStr(instruction, ";") > 0 Then
    instruction = Trim$(Left$(instruction, InStr(instruction, ";") - 1))
  Endif
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 0 
      'We have two , separated by a comman. Let's split them
      sDataA = Trim(Left$(sOpands, nOpands - 1))
      sDataB = Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands)))
    Else
      'We have one operand, let's assign it
      sDataA = sOpands
    Endif
    
  Else
    Message("Process #1 thread #" & ip_table_index1 & " died.")
    ToolBarRunMode(False)
    'Timer1.enabled = False
  Endif
  
  Select Case sOpcode
    Case I_DAT
      'the process has executed an illegal instruction
      'If this is the only thread in this warrior's process table, then this warrior has died
      If ip_table_index1 > 1 Then
        Message(" Process #1 thread #" & ip_table_index1 & " died.")
      Endif
      
      
    Case I_MOV
      'we found a MOV instruction. We have to copy the contets of one address to another.
      
    Case I_ADD
    Case I_SUB 
    Case I_MUL 
    Case I_DIV 
    Case I_MOD 
    Case I_JMP 
    Case I_JMZ 
    Case I_JMN 
    Case I_DJN 
    Case I_SPL 
    Case I_CMP 
    Case I_SEQ 
    Case I_SNE 
    Case I_SLT 
    Case I_LDP 
    Case I_STP 
    Case I_NOP  
        
  End Select
  
End


Public Sub _new()
'Is called at the start of the program
ToolBarRunMode(False)

'seed the random number generator for setting the start positions of the warriors
Randomize


End

Public Sub Form_Open()
  
  Resize_me
  Preload_Warriors
   

End

Public Sub tbQuit_Click()

  Quit

End

Public Sub tbStop_Click()

  ToolBarRunMode(False)
  Timer1.enabled = False

End

Public Sub Form_Resize()
  
  Resize_me
  
End

Public Sub tbOpen1_Click()
  OpenWarrior(1)
  
End

Public Sub tbOpen2_Click()
  OpenWarrior(2)

End

Public Sub tbRun_Click()
'copy the contents of the two warrior editors into the core array
'Dim start_position As Integer

'we need to check to see if we're in a paused state; if so, we re-enable the timer, and exit this function
If tbPause.enabled = True Then
  Timer1.Enabled = True
  ToolBarRunMode(True)
  Return
Endif

ClearCore
ToolBarRunMode(True)

'select the random position of warrior 1
warrior_start_position1 = Int(Rnd(1, 7800))

'Message(Str$(start_position))
LoadWarrior(warrior_start_position1, ed1.text, Color.Green)

'select the random position of warrior 2
warrior_start_position2 = Int(Rnd(1, 7800))
'Message(Str$(start_position))
LoadWarrior(warrior_start_position1, ed2.text, Color.Magenta)

Timer1.Enabled = True

End

Public Sub draw_Draw()
 
  

End 

Public Sub Timer1_Timer()

  'DoGravity
  'If togClear.Value Then dW.Clear()
  Wait 0.001
  Timer1.enabled = False
  Processing
  DrawCore
  Timer1.enabled = True
  
End

Public Sub DrawingArea1_Draw()

  

End

Public Sub DrawingArea1_MouseMove()

  DrawingArea1.Mouse = Mouse.Cross
  PeekCore

End

Public Sub DrawingArea1_MouseDown()

  PeekCore

End

Public Sub Form_MouseMove()

  DrawingArea1.mouse = Mouse.Default

End

Public Sub tbPause_Click()

  tbRun.enabled = True

End

Public Sub ed1_Highlight()
  'Highlight the new line
  'Code below is inspired/copied from the demo which ships with Gambas (GPL)
  'This code has not yet been tweaked to work with RedCode
  '
  Dim iState As Integer
  Dim iNextState As Integer
  Dim iInd As Integer
  Dim J As Integer
  Dim sText As String
  Dim sCar As String
  Dim iPos As Integer
  Dim bMarkup As Boolean

  iState = Highlight.State
  sText = Highlight.Text

  'PRINT "Highlight:";; iState;; sText

  For iInd = 1 To String.Len(sText)

    iNextState = iState
    sCar = String.Mid$(sText, iInd, 1)

    If bMarkup Then

      If sCar = ">" Then
        bMarkup = False
        iState = Highlight.Keyword
        iNextState = Highlight.Normal
      Else If sCar = " " Then
        iNextState = Highlight.Operator
      Else If sCar = "=" Then
        iNextState = Highlight.String
      Endif

    Else

      Select Case iState
        Case Highlight.Normal
          If sCar = "<" Then
            If String.Mid$(sText, iInd, 4) = "<!--" Then
              iState = Highlight.Comment
              iNextState = Highlight.Comment
            Else
              iState = Highlight.Keyword
              iNextState = Highlight.Keyword
              bMarkup = True
            Endif
          Else If sCar = "&" Then
            iPos = String.InStr(sText, ";", iInd)
            If iPos = 0 Or iPos = iInd + 1 Then
              iState = Highlight.Error
            Else
              For J = iInd + 1 To iPos - 1
                sCar = String.Mid$(sText, J, 1)
                If IsLetter(sCar) Then Continue
                If IsDigit(sCar) Then Continue
                If InStr("_#", sCar) Then Continue
                Break
              Next
              If J = iPos Then
                Highlight.Add(Highlight.Number, iPos - iInd + 1)
                iInd = iPos
                Continue
              Else
                iState = Highlight.Error
              Endif
            Endif
          Endif
        Case Highlight.Comment
          If sCar = ">" And If iInd > 2 And If String.Mid$(sText, iInd - 2, 2) = "--" Then
            iNextState = Highlight.Normal
          Endif
      End Select

    Endif

    Highlight.Add(iState)
    iState = iNextState

  Next

  If iNextState <> Highlight.Comment Then
    iNextState = Highlight.Normal
  Endif

  Highlight.State = iNextState
  Highlight.ShowLimit = False

End
