' Gambas class file

'this class provides the Core memory object factory
'Public core_memory[8000] As String 'stores the instruction code for each cell
Public core_memory As New String[8000] 'stores the instruction code for each cell
Public core_cell_colour As New Integer[8000] 'stores the colour of the last process which changed this cell
'Public core_cell_colour[8000] As Integer 'stores the colour of the last process which changed this cell
'Public Const Warrior1 As Integer = Color.red 'Color.red
'
'

Public Const vertical_lines As Integer = 89
Public Const horizontal_lines As Integer = 90
Public Const max_core_size As Integer = 8000

'Redcode assembly instruction codes:
'As documented in "The beginners' guide to Redcode" by Ilmari Karonen.
'
' DAT -- data (kills the process)
' MOV - - Move (copies data From one address To another)
' ADD - - add(adds one number To another)
' Sub - - subtract(subtracts one number From another)
' MUL - - multiply(multiplies one number With another)
' Div - - divide(divides one number With another)
' Mod - - modulus(divides one number With another And gives the remainder)
' JMP - - jump(continues execution From another address)
' JMZ - - jump If zero(tests a number And jumps To an address If it 's 0)
' JMN - - jump If Not zero(tests a number And jumps If it isn 't 0)
' DJN - - decrement And jump If Not zero(decrements a number by one, And jumps unless the result Is 0)
' SPL - - Split(starts a Second process at another address)
' CMP - - compare(same As SEQ)
' SEQ - - skip If equal(compares two instructions, And skips the Next instruction If they are equal)
' SNE - - skip If Not equal(compares two instructions, And skips the Next instruction If they aren 't equal)
' SLT - - skip If Lower than(compares two values, And skips the Next instruction If the first Is Lower than the Second)
' LDP - - load From p - Space(loads a number From Private storage Space)
' STP - - save To p - Space(saves a number To Private storage Space)
' NOP - - no operation(does nothing)
'
Public Const I_DAT As String = "dat"
Public Const I_MOV As String = "mov"
Public Const I_ADD As String = "add"
Public Const I_SUB As String = "sub"
Public Const I_MUL As String = "mul"
Public Const I_DIV As String = "div"
Public Const I_MOD As String = "mod"
Public Const I_JMP As String = "jmp"
Public Const I_JMZ As String = "jmz"
Public Const I_JMN As String = "jmn"
Public Const I_DJN As String = "djn"
Public Const I_SPL As String = "spl"
Public Const I_CMP As String = "cmp"
Public Const I_SEQ As String = "seq"
Public Const I_SNE As String = "sne"
Public Const I_SLT As String = "slt"
Public Const I_LDP As String = "ldp"
Public Const I_STP As String = "stp"
Public Const I_NOP As String = "nop"
Public Const I_END As String = "end"
Public Const I_ORG As String = "org"


Public Const PROCESS_1 As Integer = 1
Public Const PROCESS_2 As Integer = 2

Public process_1_colour As Integer 
Public process_2_colour As Integer


Public grid_cells_x As Integer
Public grid_cells_y As Integer

Public warrior_load_position1 As Integer
Public warrior_load_position2 As Integer

Public warrior_start_position1 As Integer
Public warrior_start_position2 As Integer

Public current_process As Integer 'nominates which process is the currently active one
Public ip_table1 As New Integer[] 'contains the two process table for the first warriors
Public ip_table2 As New Integer[] 'contains the two process table for the second warriors
Public ip_table_index1 As Integer 'specifies the current index into the instruction pointer table for warrior 1
Public ip_table_index2 As Integer 'specifies the current index into the instruction pointer table for warrior 2

Public Struct cpu_instruction
  sOpcode As String
  sOpandA As String 
  sOpandB As String
  vOpandAval As Variant
  vOpandBval As Variant
End Struct

Public current_instruction As New Cpu_instruction


Public Sub SetWarriorCellColour()
  'Call this routine once, to establish the different warrior cell colours
  process_1_colour = Color.Green
  process_2_colour = Color.Magenta
  
End


Public Function StripComments(sCode As String) As String
  'Given a string, strip out any comments, which are denoted by a semi-colon, until the end of the line
  Dim nPos As Integer
  
  nPos = InStr(sCode, ";")
  If nPos > 0 Then
    'we've found a comment, so we now excise it
    Return Trim$(Left$(sCode, nPos - 1))
  Else
    Return sCode
  Endif
  
End
Public Sub OrgAddress(warrior_id As Integer, code As String, load_point As Integer)
  'scans the supplied command line and if there is an ORG command, returns the address of where the ORG command points to
  'REMINDER: there are two forms of the org address, one is:
  '   ORG imp
  '   
  '   imp: mov 0, 1
  '   
  ' The other is the older style, designated by the nominating the ORG address in the END statement, like this:
  ' 
  '   imp: mov 0, 1
  '   
  '   end imp
  Dim code_lines, code_lines2 As String[]
  Dim code_line, code_line2, sLabel As String
  Dim nLabel, i As Integer
  
  'The strategy may need to be:
  ' scan the entire program and if there exists an ORG or an END, then split the program into separate strings, then scan each, 
  ' if it is either an ORG with a label or an END insruction, with a label, then we seek that label, and figure out the address for
  ' it by scanning all of the command lines until that label is found. Then patch the execution starting point with tha information
  
  'first thing we do is see if there is any 'org' or 'end' strings in this entire program
  If (InStr(LCase(code), I_ORG) = 0) And (InStr(LCase(code), I_END) = 0) Then Return 'If there are no END or ORG statements, there are no changes needed to the start of execution
  
  'We are here because there is either an ORG or END statement somewhere in this warrior code' let's find it.
  'For the purposes of sanity, if the warrior code includes both an program initial origin in both the ORG and in the END statement, we use the former by preference
    
  code_lines = Split(code, "\n")
  For Each code_line In code_lines
    'Strip the comments out
    code_line = Lower$(StripComments(code_line))
    nLabel = InStr(LCase(Trim(code_line)), I_ORG)
    
    If nLabel > 0 Then 'we're assuming code that looks like this:  org imp
      
      'we assueme that the label follows immediately after any white-space which follows the ORG
      nLabel = nLabel + Len(I_ORG)
      sLabel = LCase(Trim(Mid(Trim(code_line), nLabel)))
      
      'we have the label string, now we need to find it in the rest of the warrior code
      'we shall assume that the label comes after the ORG statement, so that it's somewhere in the remainder of the program code
      '
      code_lines2 = Split(code, "\n")
      For Each code_line2 In code_lines2
        'we rewind the program, and parse each line, now looking for the label we found above
        '
        'Strip the comments out
        code_line2 = Lower$(StripComments(code_line2))
        If Len(Trim(code_line2)) > 0 Then
                  
          'nLabel = InStr(LCase(Trim(code_line2)), I_ORG) 'This seems to be orphaned code
          '
          'The format which is acceptable for a label is either: 
          '    <label>  <command>
          'or: <label>: command
          'so, first we find if the line has the label with colon
          nLabel = InStr(LTrim(LCase(code_line2)), sLabel & ":")
      
          If nLabel = 0 Then
            'we're here because we couldn't find the the label with colon, so perhaps it's without colon
            nLabel = InStr(LCase(Trim(code_line2)), sLabel)
          End If
          
          If nLabel > 0 Then 'we've found our label string, so let's check if it's in the right position to be classified as a label, ie, at the start of the line
            If (Mid(code_line2, 1, Len(sLabel)) = sLabel) Or (Mid(code_line2, 1, Len(sLabel & ":")) = sLabel & ":")
              'We're here because we've found the label in the right position, i.e, at the start
              'Print "found label execution startpoint"
              'we need to set the execution point for this program as being equal to i + 1.
              Select Case warrior_id
                Case PROCESS_1
                  warrior_start_position1 = load_point + i
                  'Do we need to remove the label form this line? 
                  Return
                Case PROCESS_2
                  warrior_start_position2 = load_point + i
                  Return
              End Select
            End If
          End If
          i += 1 'This is a non-comment instruction, so we increment the counter
        End If
      Next
     
    Else
      'if this line doesn't have an ORG statement, perhaps it has an END statement. If that
      'END statement is followed by a string, then that would be categorised as a label
      
      nLabel = InStr(LCase(Trim(code_line)), I_END)
      If nLabel > 0 Then 'we're assuming code that looks like this:  end imp
      
        'we assueme that the label follows immediately after any white-space which follows the END
        nLabel = nLabel + Len(I_END)
        sLabel = LCase(Trim(Mid(Trim(code_line), nLabel)))
        'we have the label string, now we need to find it in the rest of the warrior code
        'we shall assume that the label comes after the END statement, so that it's somewhere in the remainder of the program code
        'However, as the END statement is the last statement, that means we've already gone through the warrior code, therefore, we 
        'have to "rewind" it and start from the top.
        code_lines2 = Split(code, "\n")
        For Each code_line2 In code_lines2
          'we rewind the program, and parse each line, now looking for the label we found above
          'The format which is acceptable for a label is either: <label>  <command>
          'or: <label>: command
          'so, first we find if the line has the label with colon
          nLabel = InStr(LTrim(LCase(code_line2)), sLabel & ":")
        
          If nLabel = 0 Then
            'we're here because we couldn't find the the label with colon, so perhaps it's without colon
            nLabel = InStr(LCase(Trim(code_line2)), sLabel)
            
          End If
          If nLabel > 0 Then 'we've found our label string, so let's check if it's in the right position to be classified as a label, ie, at the start of the line
            If (Mid(code_line2, 1, Len(sLabel)) = sLabel) Or (Mid(code_line2, 1, Len(sLabel & ":")) = sLabel & ":")
              ' We're here because we've found the label in the right position, i.e, at the start
              ' we need to set the execution point for this program as being equal to i + 1.
              Select Case warrior_id
                Case PROCESS_1
                  warrior_start_position1 = load_point + i
                  Return
                Case PROCESS_2
                  warrior_start_position2 = load_point + i
                  Return
              End Select
            End If
          End If
          i += 1  '
        Next
      End If
    End If
  Next    
    
End


Public Sub ClearCore()
  'Use this function to clear (or zero out) the contents of the entire core, to ensure that if another battle is run, it has a clean core
  core_memory.clear 'wipes all the core contents
  core_memory.Resize(max_core_size)
    
  core_cell_colour.Clear
  core_cell_colour.Resize(max_core_size)
  
End

Public Sub LoadWarrior(warrior_id As Integer, load_point As Integer, code As String, warrior_colour As Integer)
  'given a starting point and the code as a string, will segment the code into lines
  'and inject it into the core_memory array
  Dim code_lines As String[]
  Dim code_line As String
  Dim i, nNumLines As Integer
  
  'if there is an explicit ORG command, then we have to set the warrior execution point to be that
  'We need to figure out if this program has an ORG statement
  'and if it does, to set the start of execution accordingly
  OrgAddress(warrior_id, code, load_point)
  
  code_lines = Split(code, "\n")
  nNumLines = code_lines.Length
  
  For Each code_line In code_lines
    'Let's strip out comments
    code_line = Lower$(StripComments(code_line))
    
    'Lets process the labels. 
    If Trim$(code_line) <> "" Then
      'We have to cater for an END instruction, which means we don't want to load any more of the program, even if it is present
      If code_line = I_END Then Break
      core_memory[load_point + i] = Trim$(code_line)
      core_cell_colour[load_point + i] = warrior_colour
      'Print "Code at " & Str$(load_point + i)
      i += 1
      If load_point + i > max_core_size Then 
        'We've reached the end of the core! Reset the values so the next instruction is returned to the beginning of the core
        load_point = 0
        i = 0
      End If
    End If
  Next
  
  'we've got the code loaded, let's process the labels, removing them and swapping in
  'the correct relative addressing
  ProcessLabels(warrior_id, nNumLines)
  
End


Public Sub DrawCore()
  'Paints the drawing area with the contents of the core memory
  'use this var for our loop counter
  Dim counter As Integer
  Dim i, j, k As Integer
  Dim x1, y1, x2, y2 As Integer
  Dim stepx, stepy As Float
  Dim cursor_pos As Integer
  
  Draw.Begin(DrawingArea1)
  Draw.Clear
  Draw.FillStyle = 1
  Draw.Foreground = Color.Gray
  x1 = 0
  y1 = 0
  x2 = DrawingArea1.Width
  y2 = DrawingArea1.Height
  'Print "DrawingArea1.Height " & Str(y2) & " DrawingArea1.Width= " & Str(DrawingArea1.Width)
  stepx = (x2 - x1) / vertical_lines
  stepy = (y2 - y1) / horizontal_lines
  
  For i = 0 To vertical_lines - 1
    Draw.Line(x1 + Int(i * stepx), y1, x1 + Int(i * stepx), y2)
    'Print "i= " & i, "X= " & Int((i - 1) * stepx)
    'counter += 1      
  Next
  'Print counter 
  'grid_cells_x = i 'Set the number of grid cells in the horizontal length
  
  For j = 0 To horizontal_lines - 1
    Draw.Line(x1, y1 + Int(j * stepy), x2, y1 + Int(j * stepy))
    'Print "i= " & i, "j= " & j, "cursor_pos= " & cursor_pos, "X= " & Int(stepx * (i - 1))      
    'counter += 1  
  Next
  'Print counter
  'grid_cells_y = j 'Set the number of grid cells in the vertical length
  'Print "stepx, stepy " & Str(stepx) & ", " & Str(stepy) & ". x, y " & Int(stepx * (i - 1)) & ", " & Int(stepy * (j - 1))
  'Print grid_cells_x, grid_cells_y
  'we now paint in the programs as they appear in the core array
  Draw.FillStyle = Fill.Solid
  
  For j = 0 To horizontal_lines - 1
    For i = 0 To vertical_lines - 1
      cursor_pos = i + j * vertical_lines
      If (cursor_pos >= 0) And (cursor_pos < max_core_size) Then
        'Print core_memory[cursor_pos]
        If core_memory[cursor_pos] <> "" Then
          Draw.Foreground = core_cell_colour[cursor_pos]
          Draw.Rect(Int(stepx * i), Int(stepy * j), Int(stepx), Int(stepy))
          
          Print "cursor_pos " & cursor_pos
          'Print "i= " & i, "j= " & j, "cursor_pos= " & cursor_pos, "X= " & Int(stepx * (i - 1))
        Endif
      Else
        Draw.Foreground = Color.DarkGray
        Draw.Rect(Int(stepx * i), Int(stepy * j), Int(stepx), Int(stepy))
      Endif
      counter += 1   
    Next
  Next
  'Print "Counter " & Str(counter) & ". grid_cells_y " & Str(grid_cells_y) & ". x, y " & Int(stepx * (i - 1)) & ", " & Int(stepy * (j - 1))
  Draw.End
  
End

Public Sub ToolBarRunMode(run_mode As Boolean)
  'switches on or off most of the toolbar buttons
  
  tbPause.enabled = run_mode
  tbStop.enabled = run_mode
  tbStep.enabled = run_mode
  tbOpen1.enabled = Not run_mode
  tbSave1.enabled = Not run_mode
  tbOpen2.enabled = Not run_mode
  tbSave2.Enabled = Not run_mode
  tbRun.enabled = Not run_mode
  Timer1.enabled = run_mode
  
End


Public Sub ResizeMe()
  
  Dim x, y, PanelH As Integer
  
  'Use this routine to resize and reposition the widgets on the page
  
  x = FMain.width
  y = FMain.height 
  PanelH = Panel1.height + 10
  
  If x < 400 Then Return 'We set a lower limit for width
  If y < 400 Then Return 'We set a lower limit for height
  
  ed1.width = 285
  ed1.x = 10 ' Set the X position of the first editor
  ed1.y = PanelH 'Set the Y position of the first editor
  ed1.height = y - (PanelH + 20) 'Set the height of the first editor
  
  ed2.width = 285
  ed2.X = x - (ed2.Width + 10) ' Set the X position of the second editor
  ed2.y = PanelH 'Set the Y position of the second editor
  ed2.height = y - (PanelH + 20) 'Set the height of the second editor
 
  DrawingArea1.x = ed1.width + 20 
  DrawingArea1.y = Panel1.height + 10 'Set the Y position of the core drawing area
  DrawingArea1.width = FMain.width - (10 + ed1.width + 20 + ed2.width + 10)
  DrawingArea1.height = y - (PanelH + 20) 'Set the height of the core drawing area
   
  'Expander1.width = FMain.width - 20
  'Expander1.height = FMain.height - 50
  DrawCore
End

Public Sub PeekCore()
  'Will determine where the mouse-over correlates to the memory core, and provide that addresse's contents as a pop-up balloon item
  Dim x, y As Integer
  Dim stepx, stepy As Float
  Dim cursor_pos As Integer
  Dim core_cell_contents As String
  
  'given an x and y position on the drawing area, can we determine which cell that falls into?
  stepx = DrawingArea1.Width / vertical_lines
  stepy = DrawingArea1.Height / horizontal_lines
  'the cell number maps into the core_memory as x*91 + 88
  'Print stepx, stepy
  
  x = (Mouse.x / stepx)
  y = (Mouse.y / stepy)
  cursor_pos = x + y * vertical_lines
  'Print x, y, cursor_pos
   'Print "stepx, stepy " & Str(stepx) & ", " & Str(stepy) 
  
  If (cursor_pos >= 0) And (cursor_pos < max_core_size) Then
    'Print x, y, cursor_pos, core_memory[cursor_pos]  
    core_cell_contents = core_memory[cursor_pos]
    If core_cell_contents = "" Then core_cell_contents = "Dat #0, #0" Else core_cell_contents = core_memory[cursor_pos]
    DrawingArea1.tooltip = "Memory Address: " & Str$(cursor_pos) & " :: " & core_cell_contents
  Else
    DrawingArea1.tooltip = "Memory Address: Out of Bounds"
  End If
  
End

Public Sub OpenWarrior(warrior As Integer)
    'we need to provide the user with a file open dialog box so they can select a redcode warrior
  Dialog.Title = "Choose a Redcode Warrior file"
  Dialog.Title = "Choose a file"
  Dialog.Filter = ["*.red", "Redcode Files", "*", "All files"]
  Dialog.Path = "."
  If Dialog.OpenFile() Then
    Return ' User pressed Cancel -
  Endif
  If warrior = 1 Then
    ed1.Text = File.Load(Dialog.Path)
    Settings["warrior1"] = Dialog.Path
  Else
    ed2.Text = File.Load(Dialog.Path)
    Settings["warrior2"] = Dialog.Path
  Endif
  
Catch
  Message.Info("Error opening file\n\n" & Error.Text)
  
End

Public Sub SaveWarrior(warrior As Integer, Optional bSaveAs As Boolean)
  'we need to provide the user with a file open dialog box so they can select a redcode warrior
  Dim sPath As String
  Dialog.Title = "Save the Redcode Warrior file"
  Dialog.Title = "Specific a Filename"
  Dialog.Filter = ["*.red", "Redcode Files", "*", "All files"]
  
  If warrior = PROCESS_1 Then
    sPath = Settings["warrior1", "/home/conz/Documents/development/gambas/lmars/warriors/imp.red"]
  Else
    sPath = Settings["warrior2", "/home/conz/Documents/development/gambas/lmars/warriors/dwarf.red"]
  Endif
  
  Dialog.Path = sPath
  If Dialog.SaveFile() Then Return
  sPath = Dialog.Path
  
  If warrior = PROCESS_1 Then
    File.Save(sPath, ed1.Text)
    Settings["warrior1"] = Dialog.Path
  Else 'It's PROCESS_2
    File.Save(sPath, ed2.Text)
    Settings["warrior2"] = Dialog.Path
  Endif
  
Catch
  Message.Info("Error opening file\n\n" & Error.Text)
  
  
End
Public Sub PreloadWarriors()
  'preload the warriors last used
  ed1.text = File.Load(Settings["warrior1", "/home/conz/Documents/development/gambas/lmars/warriors/test.red"])
  ed2.text = File.Load(Settings["warrior2", "/home/conz/Documents/development/gambas/lmars/warriors/dwarf.red"])
  
End

Public Sub Processing()
  'This Is The main routine For executing the code In the battle arena
  'it begins by randozing which of the two warriors starts first
  'this routine maintains state, so the it knows what the last process table used was
  'then it executes one instruction from the process table of the first warrior
  'it then executes one instruction from the process table of the next warrior

  
  'we first check to see if we've gone through here before, i.e, is this our first point of execution?
  If current_process = 0 Then 
    ip_table1.Add(warrior_start_position1)
    ip_table2.Add(warrior_start_position2)
    'current_process = Int(Rnd(1, 3))
    'For now, let's hardwire current_process
    current_process = 1
  End If
  
  
  'We need to handle Asserts
  ' CORESIZE -- the size of the core (default 8000)
  ' PSPACESIZE - - the size Of the P - Space( Default 500)
  ' MAXCYCLES - - the number Of cycles Until a tie Is Declared( Default 80000)
  ' MAXPROCESSES - - the maximum size Of the process queue( Default 8000)
  ' WARRIORS - - the number Of programs In the core(usually 2)
  ' MAXLENGTH - - the maximum length Of a program( Default 100)
  ' CURLINE - - the number Of instructions compiled so far(0 To MAXLENGTH)
  ' MINDISTANCE - - the minimum distance between two warriors( Default 100)
  ' VERSION - - the version Of pMARS, multiplied by 100(80 Or more)
  
  ''We need to handle #defines
  '
  
  Select Case current_process
    
    Case PROCESS_1
      cpu1() 'execute the code
      ip_table1[ip_table_index1] = ip_table1[ip_table_index1] + 1 'incrememnt the instruction pointer for this process
      If ip_table1[ip_table_index1] = max_core_size
        'We've reached the end of the core! Reset the values so the next instruction is returned to the beginning of the core
        ip_table1[ip_table_index1] = 0
      Endif
    Case PROCESS_2
      'cpu2() 'execute the code
      'ip_table1[ip_table_index2] = ip_table1[ip_table_index2] + 1 'incremement the instruction pointer for this process
      'If ip_table2[ip_table_index2] > max_core_size
        'We've reached the end of the core! Reset the values so the next instruction is returned to the beginning of the core
      '  ip_table2[ip_table_index2] = 0
      'Endif
      
  End Select
  
  
End
Public Sub ProcessLabels(warrior_id As Integer, nNumLines As Integer)
  'We need to process any labels present in the core
  'We scan the total core, finding each label
  'we note its address, then we remove it from the core, 
  'and at each point where that label is referenced, we replace the label
  'with that labels actual (relative) address 
  Dim sOpcode, sOpands, sDataA, sDataB As String
  Dim nOpcode, nOpands, i, j, nAddress, nLabelPos As Integer
  Dim instruction, sIsLabel As String
  
  Select Case warrior_id
    Case PROCESS_1
      nAddress = warrior_load_position1
    Case PROCESS_2
      nAddress = warrior_load_position2 
  End Select
  
  For i = 0 To nNumLines - 1
    instruction = core_memory[nAddress + i]
    'Print instruction
    'Let's firstly look for labels, which will be strings at the start of the line, followed by whitespace
    'in a form like this: label <opcode>
    'or like this: label: <opcode>
    nOpcode = InStr(instruction, " ") - 1
    If nOpcode > 0 Then
      sIsLabel = Lower$(Left$(instruction, nOpcode))
      If IsOpCode(sIsLabel) = False Then
        'We're here because we've found the label in the right position, i.e, at the start
        'we have to deal with the label, which we do by getting just the label, then processing each
        'We firstly have to note which relative instruction this label falls on, for use later on
        'and we have to remove this label
        nLabelPos = InStr(instruction, sIsLabel)
        'we know that this line has this label, as we just extracted it from this line, so there's no need to 
        'check if we've found this label. We need to remove this label.
        core_memory[nAddress + i] = Trim(Mid(instruction, nLabelPos + Len(sIsLabel)))
        
        'Print "We've found a label: " & instruction & " -- " & sIsLabel
        'As we've found the label, let's trim it of any colons(':')
        If InStr(sIsLabel, ":") > 1 Then sIsLabel = Trim(Left(sIsLabel, Len(sIsLabel) - 1))
        For j = 0 To nNumLines - 1
          'We need to iterate through the warrior code once more, this time finding each instance of the
          'label, and replacing it with a relative reference
          'We don't have to worry if this reference is in an ORG or an END statement; we can replace both of these, too.
          
           instruction = core_memory[nAddress + j]
           'Print instruction
           'We have the instuction line, let's see if it has the label
           nLabelPos = InStr(instruction, sIsLabel)
           If nLabelPos > 0
            'we know that this line has this label, as we just extracted it from this line, so there's no need to 
            'check if we've found this label.
            'We can compute its relative position by comparing the difference between i & j counters.
            core_memory[nAddress + j] = Trim(Replace(instruction, sIsLabel, Str(i - j)))
            'Print core_memory[nAddress + j]
            'core_memory[nAddress + i] = Trim(Left(instruction, nLabelPos - 1) & Str(i - j) & Mid(instruction, nLabelPos + Len(sIsLabel)))         
               
           Endif
        Next
      End If
    End If
  Next
  
End
Public Sub ExtractOpandB(instruction As String) As String
  'Given an instruction string, figure out OpandB and return it as substring
  'thus DAT #1, #3 will return #3
  '
  Dim nOpcode, nOpands As Integer
  Dim sOpcode, sOpands As String
  
    'examples of each kind of instruction, from
  'http://en.wikibooks.org/wiki/Core_War/Redcode
  'DAT A,B  Data; executing this instruction kills the task.
  ' MOV #A, B If one Is Immediate, copied immediate number To B.
  ' MOV A, B Moves instruction at A To B.However, If A Is Immediate, copies the immediate number To B.
  ' ADD A, B Adds A To B.
  ' Sub A, B Subtracts A From B.
  ' MUL A, B Multiplies A And B To produce the result.
  ' Div A, B Divides B by A.Division by zero kills the process.
  ' Mod A, B Modulus Of B In A.Division by zero kills the process.
  ' JMP A, B Jumpts To A.
  ' JMZ A B If * B Is 0, jumps To A.
  ' JMN A, B If * B Is Not 0, jumps To A.
  ' DJN A, B Decreases * b.If non zero, jumps To A.
  ' CMP A, B If * a == * B( Or If immediate, #A == * B), skips an instruction
  ' SPL A, B Creates a New Task, which starts at B.Newer task starts first.
  ' SEQ A, B Skips past the Next instruction Is A And B are equal.
  ' SNE A, B Skips past the Next instruction Is A And B are Not - equal.
  ' SLT A, B Skips If * A < * B.(88 only)
  ' XCH A, B At A, swaps A And B.(extended only)
  ' PCT A, B At A, Protects operands From changing, Until an instruction Is Written To that address.
  ' NOP A, B Has no special effect(although operands are still evaluates.)
  ' STP A, B Stores A into P - Space at location specified by B.
  ' LDP A, B Retrieves data From P - Space at location specified by B into A.
  ' 
  ' 
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 0 
      Return RemoveNonMaths(Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands))))
    Endif
  Endif
End
Public Sub ExtractOpandBVal(instruction As String) As Integer
  'Given an instruction string, figure out OpandB and return its value
  '
  Dim nOpcode, nOpands As Integer
  Dim sOpcode, sOpands As String
  
    'examples of each kind of instruction, from
  'http://en.wikibooks.org/wiki/Core_War/Redcode
  'DAT A,B  Data; executing this instruction kills the task.
  ' MOV #A, B If one Is Immediate, copied immediate number To B.
  ' MOV A, B Moves instruction at A To B.However, If A Is Immediate, copies the immediate number To B.
  ' ADD A, B Adds A To B.
  ' Sub A, B Subtracts A From B.
  ' MUL A, B Multiplies A And B To produce the result.
  ' Div A, B Divides B by A.Division by zero kills the process.
  ' Mod A, B Modulus Of B In A.Division by zero kills the process.
  ' JMP A, B Jumpts To A.
  ' JMZ A B If * B Is 0, jumps To A.
  ' JMN A, B If * B Is Not 0, jumps To A.
  ' DJN A, B Decreases * b.If non zero, jumps To A.
  ' CMP A, B If * a == * B( Or If immediate, #A == * B), skips an instruction
  ' SPL A, B Creates a New Task, which starts at B.Newer task starts first.
  ' SEQ A, B Skips past the Next instruction Is A And B are equal.
  ' SNE A, B Skips past the Next instruction Is A And B are Not - equal.
  ' SLT A, B Skips If * A < * B.(88 only)
  ' XCH A, B At A, swaps A And B.(extended only)
  ' PCT A, B At A, Protects operands From changing, Until an instruction Is Written To that address.
  ' NOP A, B Has no special effect(although operands are still evaluates.)
  ' STP A, B Stores A into P - Space at location specified by B.
  ' LDP A, B Retrieves data From P - Space at location specified by B into A.
  ' 
  ' 
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 0 
      Return Eval(Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands))))
    Endif
  Endif
End
Public Sub ExtractOpandA(instruction As String) As String
  'Given an instruction string, figure out OpandA and return it
  
  Dim nOpcode, nOpands As Integer
  Dim sOpcode, sOpands As String
  
    'examples of each kind of instruction, from
  'http://en.wikibooks.org/wiki/Core_War/Redcode
  'DAT A,B  Data; executing this instruction kills the task.
  ' MOV #A, B If one Is Immediate, copied immediate number To B.
  ' MOV A, B Moves instruction at A To B.However, If A Is Immediate, copies the immediate number To B.
  ' ADD A, B Adds A To B.
  ' Sub A, B Subtracts A From B.
  ' MUL A, B Multiplies A And B To produce the result.
  ' Div A, B Divides B by A.Division by zero kills the process.
  ' Mod A, B Modulus Of B In A.Division by zero kills the process.
  ' JMP A, B Jumpts To A.
  ' JMZ A B If * B Is 0, jumps To A.
  ' JMN A, B If * B Is Not 0, jumps To A.
  ' DJN A, B Decreases * b.If non zero, jumps To A.
  ' CMP A, B If * a == * B( Or If immediate, #A == * B), skips an instruction
  ' SPL A, B Creates a New Task, which starts at B.Newer task starts first.
  ' SEQ A, B Skips past the Next instruction Is A And B are equal.
  ' SNE A, B Skips past the Next instruction Is A And B are Not - equal.
  ' SLT A, B Skips If * A < * B.(88 only)
  ' XCH A, B At A, swaps A And B.(extended only)
  ' PCT A, B At A, Protects operands From changing, Until an instruction Is Written To that address.
  ' NOP A, B Has no special effect(although operands are still evaluates.)
  ' STP A, B Stores A into P - Space at location specified by B.
  ' LDP A, B Retrieves data From P - Space at location specified by B into A.
  ' 
  ' 
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 1
      Return Trim$(Left$(sOpands, nOpands - 1))
    Endif
  Endif
End
 
Public Function RemoveNonMaths(sRawNum As String) As String 
  'Removes all non numeric characters from a string.
   Dim numeric_chars As String = "0123456789+-*/%=!<>&|#@$" 
   Dim i As Integer 
   Dim sResult As String = ""
   
   For i = 1 To Len(sRawNum) 
    If InStr(numeric_chars, Mid$(sRawNum, i, 1)) > 0 Then 
      'Found a numeric character 
      sResult = sResult & Mid$(sRawNum, i, 1) 
    End If 
   Next 
   'Return the result 
   Return sResult
   
End Function


Public Sub ResolveOpandValue(sOpand As String, nAddress As Integer) As Variant
  'Given an opand and a memory location, figure out what the data is that results, then return this
  ' Address modes - from http://en.wikibooks.org/wiki/Core_War/Redcode
  ' Each opcod listed above contains two registers.These registers are composed Of both a number And an address mode: 
  ' #Immediate.The number Is Directly In the opcode.
  ' $( Or none)Direct.The opcode points To a cell relative To the current cell.
  ' @Indirect.The opcode points To a cell relative To the current cell.That cell 's B value is added o the indirect pointer, to provide the target.
  ' < Indirect, but the intermediate register Is Decreased before use.
  ' > Indirect, the intermediate register Is Increased after use.
  ' * A - field Indirect.The opcode points To a cell relative To the current cell.That cell 's A value is added to the indirect pointer, to provide the target.
  ' {  A-field Indirect, but the intermediate register is decreased before use.
  ' }A - field Indirect, the intermediate register Is Increased after use. 
  
  Print sOpand, nAddress
  Select Case Trim$(Left(sOpand, 1))
    Case "#"
      ' #Immediate.The number Is Directly In the opcode.
      ' I assume that this result should be supplied back as a DAT command, with direct value placed in the B field, thus
      'Return "dat #0, #" & Str(Eval(Mid(sOpand, 2))) 
      Return Eval(Mid(sOpand, 2))
      
    Case "@"
      ' @Indirect.The opcode points To a cell relative To the current cell.That cell 's B value is added o the indirect pointer, to provide the target.
      'Return core_memory[nAddress + ExtractOpandB(core_memory[nAddress + Eval(Mid(sOpand, 2))])]
      Return nAddress + Eval(ExtractOpandBVal(core_memory[nAddress + Eval(Mid(sOpand, 2))])) & ""
    Case "<"  
      ' < Indirect, but the intermediate register Is Decreased before use.
      Message("Now idea how to handle this yet")
      
    Case ">"
      ' > Indirect, the intermediate register Is Increased after use.
      Message("Now idea how to handle this yet")
      
    Case "*"
      ' * A - field Indirect.The opcode points To a cell relative To the current cell.That cell 's A value is added to the indirect pointer, to provide the target.
      Message("Now idea how to handle this yet")
      
    Case Else
      'We are here when we can find none of the above, so that means, assuming either $ or nothing, which is Direct
      'The opcode points To a cell relative To the current cell.
       
       'Return core_memory[nAddress + Eval(sOpand)]
       Return (nAddress + Eval(sOpand))
  End Select
  
End

Public Function ExtractInstruction(instruction As String) As Boolean
  'Given the current instruction pointer, extract the text and values for the opcodes and operands
  'if there is a problem, return false, else true
  'This is a helper function called by cpu()
  'Dim sOpcode, sOpands, sOpandA, sOpandB As String
  Dim nOpcode, nOpands As Integer
  'Dim instruction, sIsLabel, new_instruction As String
  'Dim vRet, vResult, vOpandA, vOpandB As Variant
  Dim sOpands As String
  
  
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    current_instruction.sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 0 
      'We have two , separated by a comman. Let's split them
      current_instruction.sOpandA = Trim(Left$(sOpands, nOpands - 1))
      current_instruction.sOpandB = Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands)))
    Else
      'We have one operand, let's assign it
      current_instruction.sOpandA = sOpands
    Endif
    
  Else
    'this is not a valid instruction, return false
    Return False
  Endif
  
  current_instruction.vOpandAval = ResolveOpAndValue(current_instruction.sOpandA, ip_table1[ip_table_index1])
  current_instruction.vOpandBval = ResolveOpAndValue(current_instruction.sOpandB, ip_table1[ip_table_index1])
  
  
  Return True
End



Public Sub cpu1()
  'This is the routine which executes the code in the array
  Dim sOpcode, sOpands, sOpandA, sOpandB As String
  Dim nOpcode, nOpands As Integer
  Dim instruction, sIsLabel, new_instruction As String
  Dim vRet, vResult, vOpandA, vOpandB As Variant
  
  instruction = core_memory[ip_table1[ip_table_index1]]
  'first, we remove any comments
  If InStr(instruction, ";") > 0 Then
    instruction = Trim$(Left$(instruction, InStr(instruction, ";") - 1))
  Endif
  
  'examples of each kind of instruction, from
  'http://en.wikibooks.org/wiki/Core_War/Redcode
  'DAT A,B  Data; executing this instruction kills the task.
  ' MOV #A, B If one Is Immediate, copied immediate number To B.
  ' MOV A, B Moves instruction at A To B.However, If A Is Immediate, copies the immediate number To B.
  ' ADD A, B Adds A To B.
  ' Sub A, B Subtracts A From B.
  ' MUL A, B Multiplies A And B To produce the result.
  ' Div A, B Divides B by A.Division by zero kills the process.
  ' Mod A, B Modulus Of B In A.Division by zero kills the process.
  ' JMP A, B Jumpts To A.
  ' JMZ A B If * B Is 0, jumps To A.
  ' JMN A, B If * B Is Not 0, jumps To A.
  ' DJN A, B Decreases * b.If non zero, jumps To A.
  ' CMP A, B If * a == * B( Or If immediate, #A == * B), skips an instruction
  ' SPL A, B Creates a New Task, which starts at B.Newer task starts first.
  ' SEQ A, B Skips past the Next instruction Is A And B are equal.
  ' SNE A, B Skips past the Next instruction Is A And B are Not - equal.
  ' SLT A, B Skips If * A < * B.(88 only)
  ' XCH A, B At A, swaps A And B.(extended only)
  ' PCT A, B At A, Protects operands From changing, Until an instruction Is Written To that address.
  ' NOP A, B Has no special effect(although operands are still evaluates.)
  ' STP A, B Stores A into P - Space at location specified by B.
  ' LDP A, B Retrieves data From P - Space at location specified by B into A.
  ' 
  ' 
  'split the instruction string
  'find the opcode boundary.
  nOpcode = InStr(instruction, " ") - 1
  If nOpcode > 0 Then
    sOpcode = Lower$(Left$(instruction, nOpcode))
    sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
    nOpands = InStr(sOpands, ",")
    If nOpands > 0 
      'We have two , separated by a comman. Let's split them
      sOpandA = Trim(Left$(sOpands, nOpands - 1))
      sOpandB = Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands)))
    Else
      'We have one operand, let's assign it
      sOpandA = sOpands
    Endif
    
  Else
    Message(" Process #1 thread #" & ip_table_index1 & " died executing an invalid instruction at: #" & ip_table1[ip_table_index1])
    ToolBarRunMode(False)
    'Timer1.enabled = False
  Endif
  
  
  'Instruction modifiers[edit].A  A -> A
  ' .B B - > B
  ' .AB A - > B
  ' .BA B - > A
  ' .F A - > A And B - > B
  ' .X A - > B And B - > A
  ' .I Entire instruction.
  ' 
  Select Case sOpcode
    Case I_DAT
      'the process has executed an illegal instruction
      'If this is the only thread in this warrior's process table, then this warrior has died
      If ip_table_index1 > 1 Then
        Message(" Process #1 thread #" & ip_table_index1 & " died executing an invalid instruction at: #" & ip_table1[ip_table_index1])
      Endif
      
      
    Case I_MOV
      'we found a MOV instruction. We have to copy the contents of one address to another.
      'we first resolve the value of the  sOpandA and shove that value into the addresses resolved by sOpandB
      'sOpandA is the source of the information
      'sOpandB is the destination where the information is to be moved to
      vRet = ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])
      
      Select Case TypeOf(vRet)
        Case gb.Integer
        '
        core_memory[vRet] = core_memory[ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])]
      Case gb.String
        
      Case gb.Float
        'We are here because we've got an indirect @address, so, in the address pointed to by that indirect value, we place the value from the A opand.
        '
        core_memory[Int(vRet)] = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      End Select
      
      'core_memory[vRet] = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      
      core_cell_colour[vRet] = PROCESS_1_COLOUR
      '
    Case I_ADD
      'we found a ADD instruction. We have to add the evaluated contents of the two operands
      'ADD, SUB, MUL, DIV, MOD
      'If A - mode Is Immediate, .AB,
      'If B - mode Is Immediate And A - mode isn 't, .B,
      'If neither mode Is Immediate, .F.
      'Example of both opands being immediate
      'ADD #10, #-1
      ' The add command adds the "A" field To the "B" field.Here both fields are In immediate mode, so the operation takes place On one line.
      ' After executing this instruction once, it would look As Follows.
      ' ADD   #10,  #9
      ' Another example is 
      '   ADD 1, 2
      ' what this does is takes the B operand the cell one address beyond, and adds it to the B operand two addresses beyond
      ' thus:
      '   ADD 1, 2
      '   DAT #0, #4
      '   DAT #1, #0
      '   
      ' becomes:
      '   ADD 1, 2
      '   DAT #0, #4
      '   DAT #1, #4
      
      vOpandA = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      vOpandB = ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])
      Select Case TypeOf(vOpandA)
        Case gb.Integer
          'we are here becase sOpandA is a direct address in the ADD.
          'Let's get the instruction pointed to by current instruction' A opand
          vRet = vOpandA            
          instruction = core_memory[vOpandA]
          'If that instruction is blank, make it a legal blank: dat #0, #0
          If instruction = "" Then instruction = "dat #0, #0"
          nOpcode = InStr(instruction, " ") - 1
          'Split the opcodes and opands
          If nOpcode > 0 Then
            sOpcode = Lower$(Left$(instruction, nOpcode))
            'We need to check if this is an actual Opcode, if not, then we populate this field with a DAT 
            If IsOpCode(sOpcode) Then
              sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
              nOpands = InStr(sOpands, ",")
              If nOpands > 0 Then
                'we have a valid opcode & opands instruction, like dat A, B. We need to extract the B opand
                vResult = ResolveOpandValue(ExtractOpandB(instruction), Int(vOpandA))
                'We have the value of B
                'new_instruction = sOpcode & " " & ExtractOpandA(instruction) & ", #" & RemoveNonMaths(Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands))))
              Endif
            Endif
              'new_instruction = "dat #0" & core_memory[ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])]
          Else
             'new_instruction = "dat #0" & core_memory[ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])]
          Endif
          
          'Let's get the instruction pointed to by current instruction' B opand   
          instruction = core_memory[Int(vOpandB)]
          'If that instruction is blank, make it a legal blank: dat #0, #0
          If instruction = "" Then instruction = "dat #0, #0"
          nOpcode = InStr(instruction, " ") - 1
          'Split the opcodes and opands
          If nOpcode > 0 Then
            sOpcode = Lower$(Left$(instruction, nOpcode))
            'We need to check if this is an actual Opcode, if not, then we populate this field with a DAT 
            If IsOpCode(sOpcode) Then
              sOpands = Trim$(Mid$(instruction, nOpcode + 1, Len(instruction)))
              nOpands = InStr(sOpands, ",")
              
              If nOpands > 0 Then
                'we have a valid opcode & opands instruction, like dat A, B.
                'we need to add the vResult from above to the B value of this instruction
                '   DAT #0, #4
                '   DAT #1, #0
                '   
                ' becomes:
                '   DAT #0, #4
                '   DAT #1, #4 
                ' new_instruction = sOpcode & " " & ExtractOpandA(instruction) & ", " & RemoveNonMaths(Trim$(Mid$(sOpands, nOpands + 1, Len(sOpands))))
                new_instruction = sOpcode & " " & ExtractOpandA(instruction) & ", #" & Str(ResolveOpAndValue(ExtractOpandB(instruction), ip_table1[ip_table_index1]) + vResult)
              Endif
            Endif
              'new_instruction = "dat #0" & core_memory[ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])]
          Else
             new_instruction = "dat #0" & core_memory[ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])]
          Endif
          
          'We now have to figure out what the sOpandB is for the instruction at the address pointed vy vRet and add to it
          '
          sOpandB = ExtractOpandB(core_memory[vRet])
          
          core_memory[vOpandB] = new_instruction
          core_cell_colour[vRet] = PROCESS_1_COLOUR
      Case gb.String
          'This is not needed presently
          
      Case gb.Float
        'We are here because we've got an indirect @address, so, in the address pointed to by that indirect value, we place the value from the A opand.
        '
        core_memory[Int(vRet)] = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      End Select
      
      'core_memory[vRet] = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      
      
    Case I_SUB
      'we found a SUB instruction. We have to subtract the evaluated contents of the two operands
      'ADD, SUB, MUL, DIV, MOD
      'If A - mode Is Immediate, .AB,
      'If B - mode Is Immediate And A - mode isn 't, .B,
      'If neither mode Is Immediate, .F.
      'This instruction works exactly like ADD, except for one fairly obvious difference. In
      'fact, all the "arithmetic-logical" instructions work pretty much the same...
      'Example of both opands being immediate
      '   SUB #10, #-1
      ' The sub command subtracts the "A" field To the "B" field.Here both fields are In immediate mode, so the operation takes place On one line.
      ' After executing this instruction once, it would look As Follows.
      '   SUB   #10,  #9
      ' Another example is 
      '   ADD 1, 2
      ' what this does is takes the B operand the cell one address beyond, and adds it to the B operand two addresses beyond
      ' thus:
      '   SUB 1, 2
      '   DAT #0, #4
      '   DAT #1, #0
      '   
      ' becomes:
      '   SUB 1, 2
      '   DAT #0, #4
      '   DAT #1, #-4
      vOpandA = ResolveOpAndValue(sOpandA, ip_table1[ip_table_index1])
      vOpandB = ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])
      Select Case TypeOf(vOpandA)
        Case gb.Integer
          'we are here becase sOpandA is a direct address in the SUB.
          'Let's get the instruction pointed to by current instruction' A opand

          vRet = vOpandA            
          instruction = core_memory[vOpandA]
          If ExtractInstruction(instruction) = False Then
            'we are here because there's a problem with the instruction
            Message(" Process #1 thread #" & ip_table_index1 & " died executing an invalid instruction at: #" & ip_table1[ip_table_index1])
            ToolBarRunMode(False)
          Endif
          'We should have the value of the operand we're going to subrtact
          vResult = current_instruction.vOpandBval
          'Let's get the instruction pointed to by current instruction' B opand   
          instruction = core_memory[Int(vOpandB)]
          'If that instruction is blank, make it a legal blank: dat #0, #0
          If instruction = "" Then instruction = "dat #0, #0"
          If ExtractInstruction(instruction) = False Then
            'we are here because there's a problem with the instruction
            Message(" Process #1 thread #" & ip_table_index1 & " died executing an invalid instruction at: #" & ip_table1[ip_table_index1])
            ToolBarRunMode(False)
          Endif
          
          new_instruction = current_instruction.sOpcode & " " & current_instruction.sOpandA & ", #" & Str(ResolveOpAndValue(current_instruction.sOpandB, ip_table1[ip_table_index1]) - vResult)
          
          'Else
          '   new_instruction = "dat #0" & core_memory[ResolveOpAndValue(sOpandB, ip_table1[ip_table_index1])]
          'Endif
          
          'We now have to figure out what the sOpandB is for the instruction at the address pointed vy vRet and add to it
          '
          sOpandB = ExtractOpandB(core_memory[vRet])
          
          core_memory[vOpandB] = new_instruction
          core_cell_colour[vOpandB] = PROCESS_1_COLOUR
          
        Case gb.String
          'This is not needed presently
          
      Case gb.Float
        'We are here because we've got an indirect @address, so, in the address pointed to by that indirect value, we place the value from the A opand.

      End Select  
    Case I_MUL 
    Case I_DIV 
    Case I_MOD 
    Case I_JMP 
    Case I_JMZ 
    Case I_JMN 
    Case I_DJN 
    Case I_SPL 
    Case I_CMP 
    Case I_SEQ 
    Case I_SNE 
    Case I_SLT 
    Case I_LDP 
    Case I_STP 
    Case I_NOP
      'We do nothing
      '
    Case I_ORG
      'We do nothing. This line just points to where execution should begin
      Print instruction
        
  End Select
  
End

'==========================================================
 '                                         Muhammad Abubakar
 '                                     <joehacker@yahoo.com>
 '                                   <http://go.to/abubakar>
 '==========================================================
 'You can use the code as u like in your projects but please
 'give credit where credit is due :)
Public Sub IsOpCode(instruction As String) As Boolean
  'We check to see if this is an actual opcode
  'if not, return fals
  Select Case instruction
    Case I_DAT
      Return True
    Case I_MOV
      Return True
    Case I_ADD
      Return True
    Case I_SUB 
      Return True
    Case I_MUL 
      Return True
    Case I_DIV 
      Return True
    Case I_MOD 
      Return True
    Case I_JMP 
      Return True
    Case I_JMZ 
      Return True
    Case I_JMN 
      Return True
    Case I_DJN 
      Return True
    Case I_SPL 
      Return True
    Case I_CMP 
      Return True
    Case I_SEQ 
      Return True
    Case I_SNE 
      Return True
    Case I_SLT 
      Return True
    Case I_LDP 
      Return True
    Case I_STP 
      Return True
    Case I_NOP  
      Return True
    Case I_ORG
      Return True
    Case I_END
      Return True
    Case Else
      Return False
        
  End Select
  Return 
End


 Public Function parse(expr As String) As Float
     Dim i As Float, a As String
     Dim start As Float, endat As Float
    
     expr = Trim(expr)
     If InStr(expr, "(") <> 0 Then
         i = 1
         While (InStr(expr, "(") <> 0)
             a = Mid(expr, i, 1)
             If a = "(" Then
                 start = i
                 
             Else If a = ")" Then
                 If start = 0 Then
                     'MsgBox "Invalid Syntax."
                     Return
                 
                 End If
                 endat = i
                 i = Val(givePrecedence(Mid(expr, start + 1, endat - start - 1)))
                 expr = Left(expr, start - 1) & Str(i) & Right(expr, Len(expr) - endat)
                 start = 0
                 endat = 0
                 i = 0
             End If
             i = i + 1
         Wend
     End If
     If expr <> "" Then
       Return Val(givePrecedence(expr))
     Else
       Return i 
     End If
 End Function

 Private Function Evaluate(sTemp As String, sign As String, prevExpr As String) As String
     Select Case sign
         Case "+"
             Return Str(Val(prevExpr) + Val(sTemp))
         Case "-"
             Return Str(Val(prevExpr) - Val(sTemp))
         Case "*"
             Return Str(Val(prevExpr) * Val(sTemp))
         Case "/"
             Return Str(Val(prevExpr) / Val(sTemp))
         Case "^"
             Return Str(Val(prevExpr) ^ Val(sTemp))
     End Select
 End Function

 Private Function givePrecedence(expr As String) As String
     Dim X As Integer
     Dim sTemp As String
     
     Do While (InStr(expr, "!") <> 0 Or InStr(expr, "*") <> 0 Or InStr(expr, "/") <> 0 Or InStr(expr, "^") <> 0 Or InStr(expr, "+") <> 0 Or InStr(expr, "-") <> 0)
         Wait
         X = InStr(expr, "!")
         If X <> 0 Then
             sTemp = solveFor("!", expr)
         Else
             X = InStr(expr, "^")
             If X <> 0 Then
                 sTemp = solveFor("^", expr)
             Else
                 X = InStr(expr, "/")
                 If X <> 0 Then
                     sTemp = solveFor("/", expr)
                 Else
                     X = InStr(expr, "*")
                     If X <> 0 Then
                         sTemp = solveFor("*", expr)
                     Else
                         X = InStr(expr, "+")
                         If X <> 0 Then
                            sTemp = solveFor("+", expr)
                         Else
                             X = InStr(expr, "-")
                             If X <> 0 Then
                                 sTemp = solveFor("-", expr)
                             End If
                         End If
                     End If
                 End If
             End If
         End If
         If sTemp = "" Then
             Break
         Else
             expr = sTemp
         End If
     Loop
     Return expr
     
 End Function
 Private Function GetNumFrom(Pos As Integer, expr As String) As String
     Dim i As Integer
     Dim sTemp As String
     Dim a As String
     
     If Pos <= Len(expr) Then
         For i = Pos To Len(expr)
         '{
             a = Mid(expr, i, 1)
             If Asc(a) >= 48 And Asc(a) <= 58 Or a = " " Or a = "." Or ((a = "-" Or a = "+") And Trim(Temp) = "") Then
                 sTemp = sTemp & a
             Else
                 If LCase(a) = "e" Then
                 sTemp = sTemp & "E" & GetNumFrom(i + 1, expr) 'Recursion
                 i = Len(expr)
                 Else
                 'wrong syntax, u can handle error as you like
                 End If
             i = Len(expr)
             End If
         Next
         '}
     Return Temp
     End If
 End Function
 Private Function solveFor(sign As String, expr As String) As String
         '{
             Dim X As Integer, start As Integer, endat As Integer
             Dim sTemp As String, a As String, i As Integer
             start = 1
             X = InStr(expr, sign)
             If sign <> "!" Then
                 If sign = "+" Or sign = "-" Then
                     a = GetNumFrom(1, expr)
                     If Len(a) = Len(expr) Then
                         Return ""

                     End If
                     sTemp = GetNumFrom(Len(a) + 1, expr)
                     If Sgn(Val(sTemp)) < 0 Then
                        sign = "-" 
                      Else 
                        sign = "+"
                     End If
                     X = InStr(Len(a), expr, sign)
                     endat = Len(a) + Len(sTemp)
                     sTemp = Evaluate(GetNumFrom(X + 1, expr), sign, a)
                     expr = Left(expr, start - 1) & sTemp & Right(expr, Len(expr) - endat)
                     Return expr
                     
                 End If
             End If
             'i = InStr(x + 1, expr, sign)
             
             For i = X - 1 To 1 Step -1 'going back
                 a = Mid(expr, i, 1)
                 If Asc(a) >= 48 And Asc(a) <= 58 Or a = " " Or a = "." Or LCase(a) = "e" Then
                     sTemp = a & sTemp
                 Else
                     If (a = "-" Or a = "+") And i - 1 > 0 Then
                         If Mid(expr, i - 1, 1) = "e" Then
                             sTemp = a & sTemp
                         Else
                             start = i + 1
                             i = 1
                         End If
                     Else
                         start = i + 1
                         i = 1
                     End If
                 End If
             Next
             If Trim(sTemp) <> "" Then
                 'solving for factorial
                 If sign = "!" Then
                     If Int(Val(sTemp)) <> Val(sTemp) Then
                         'wrong syntax, handle it in whatever way u awnt
                     Else
                         expr = Left(expr, start - 1) & Str(fact(Val(sTemp))) & Right(expr, Len(expr) - X)
                         Return expr
                     End If
                 Else
                     'its not a factorial calculations
                     endat = X + Len(GetNumFrom(X + 1, expr))
                     sTemp = Evaluate(GetNumFrom(X + 1, expr), sign, sTemp)
                     expr = Left(expr, start - 1) & sTemp & Right(expr, Len(expr) - endat)
                     'Job done, go back
                     Return expr
                 End If
             Else
                 Return ""
             End If
             
 End Function
 
 'Algo for factorial
 Private Function fact(num As Integer) As Float
     Dim b As Float
     Dim i As Integer
     b = 1
     For i = 1 To num
         b = b * i 'I wish I could write it as b * = num :(
     Next
     Return b

 End Function


Public Sub _new()
'Is called at the start of the program
ToolBarRunMode(False)

'seed the random number generator for setting the start positions of the warriors
Randomize


End

Public Sub Form_Open()
  
  ResizeMe
  PreloadWarriors
   

End

Public Sub tbQuit_Click()

  Quit

End

Public Sub tbStop_Click()

  ToolBarRunMode(False)
  'Timer1.enabled = False

End

Public Sub Form_Resize()
  
  ResizeMe
  
End

Public Sub tbOpen1_Click()
  OpenWarrior(PROCESS_1)
  
End

Public Sub tbOpen2_Click()
  OpenWarrior(PROCESS_2)

End

Public Sub tbRun_Click()
'copy the contents of the two warrior editors into the core array
'Dim start_position As Integer

'we need to check to see if we're in a paused state; if so, we re-enable the timer, and exit this function
If tbStop.enabled = True Then
  'Timer1.Enabled = True
  ToolBarRunMode(True)
  Return
Endif

ClearCore
SetWarriorCellColour
ToolBarRunMode(True)

'select the random position of warrior 1
warrior_load_position1 = Int(Rnd(0, max_core_size - 1))
'warrior_load_position1 = 0
warrior_start_position1 = warrior_load_position1
'Print "warrior_load_position1 " & warrior_start_position1

'Message(Str$(start_position))
LoadWarrior(PROCESS_1, warrior_load_position1, ed1.text, PROCESS_1_COLOUR)

ip_table1.Clear 'Clear the process table

'select the random position of warrior 2
warrior_load_position2 = Int(Rnd(0, max_core_size - 1))
'warrior_load_position2 = 5
warrior_start_position2 = warrior_load_position2
'Print "warrior_load_position2 " & warrior_start_position2

'Message(Str$(start_position))
LoadWarrior(PROCESS_2, warrior_load_position2, ed2.text, PROCESS_2_COLOUR)

ip_table2.Clear 'Clear the process table

current_process = 0 'reset the current process to be zero

Timer1.Enabled = True

End

Public Sub draw_Draw()
 
  

End 

Public Sub Timer1_Timer()

  'Wait 0.001
  'Timer1.enabled = False
  Processing
  DrawCore
  'Timer1.enabled = True
  
End

Public Sub DrawingArea1_Draw()

  

End

Public Sub DrawingArea1_MouseMove()

  DrawingArea1.Mouse = Mouse.Arrow
  PeekCore

End

Public Sub DrawingArea1_MouseDown()
  'Print "Mouse.y = " & Str(Mouse.y)
  PeekCore

End

Public Sub Form_MouseMove()

  DrawingArea1.mouse = Mouse.Default

End

Public Sub tbPause_Click()

  tbRun.enabled = True
  tbPause.enabled = False
  Timer1.enabled = False

End

Public Sub ed1_Highlight()
  'Highlight the new line
  'Code below is inspired/copied from the demo which ships with Gambas (GPL)
  'This code has not yet been tweaked to work with RedCode
  '
  Dim iState As Integer
  Dim iNextState As Integer
  Dim iInd As Integer
  Dim J As Integer
  Dim sText As String
  Dim sCar As String
  Dim iPos As Integer
  Dim bMarkup As Boolean

  iState = Highlight.State
  sText = Highlight.Text

  'PRINT "Highlight:";; iState;; sText

  For iInd = 1 To String.Len(sText)

    iNextState = iState
    sCar = String.Mid$(sText, iInd, 1)

    If bMarkup Then

      If sCar = ">" Then
        bMarkup = False
        iState = Highlight.Keyword
        iNextState = Highlight.Normal
      Else If sCar = " " Then
        iNextState = Highlight.Operator
      Else If sCar = "=" Then
        iNextState = Highlight.String
      Endif

    Else

      Select Case iState
        Case Highlight.Normal
          If sCar = "<" Then
            If String.Mid$(sText, iInd, 4) = "<!--" Then
              iState = Highlight.Comment
              iNextState = Highlight.Comment
            Else
              iState = Highlight.Keyword
              iNextState = Highlight.Keyword
              bMarkup = True
            Endif
          Else If sCar = "&" Then
            iPos = String.InStr(sText, ";", iInd)
            If iPos = 0 Or iPos = iInd + 1 Then
              iState = Highlight.Error
            Else
              For J = iInd + 1 To iPos - 1
                sCar = String.Mid$(sText, J, 1)
                If IsLetter(sCar) Then Continue
                If IsDigit(sCar) Then Continue
                If InStr("_#", sCar) Then Continue
                Break
              Next
              If J = iPos Then
                Highlight.Add(Highlight.Number, iPos - iInd + 1)
                iInd = iPos
                Continue
              Else
                iState = Highlight.Error
              Endif
            Endif
          Endif
        Case Highlight.Comment
          If sCar = ">" And If iInd > 2 And If String.Mid$(sText, iInd - 2, 2) = "--" Then
            iNextState = Highlight.Normal
          Endif
      End Select

    Endif

    Highlight.Add(iState)
    iState = iNextState

  Next

  If iNextState <> Highlight.Comment Then
    iNextState = Highlight.Normal
  Endif

  Highlight.State = iNextState
  Highlight.ShowLimit = False

End

Public Sub tbSave1_Click()

  SaveWarrior(PROCESS_1)

End

Public Sub tbSave2_Click()

  SaveWarrior(PROCESS_2)

End
